<?php
// This file contains various utility functions for handling IP addresses, file operations, and string manipulation

// srand(time()); // Unnecessary in modern PHP - Random number generation is automatically seeded in modern PHP
// Initialize logging
$logFile = __DIR__ . '/email_sending_' . date('Ymd_His') . '.log';
$startTime = time();
$maxExecutionTime = 3600; // 1 hour max execution time
$maxEmailTime = 300; // 5 minutes max per email
$lastEmailTime = 0;
logMessage("=== Starting email sending process. Total emails: $vallent ===", $logFile);

/**
 * Checks if the given IP address is within Google Cloud's IP ranges
 * @param string $myIp The IP address to check
 * @return bool True if IP is in Google Cloud range, false otherwise
 */
function isMyIpInGoogleCloudRange($myIp) {

   
    $netblockHosts = [
        '_cloud-netblocks.googleusercontent.com',
        '_cloud-netblocks1.googleusercontent.com',
        '_cloud-netblocks2.googleusercontent.com',
        '_cloud-netblocks3.googleusercontent.com',
        '_cloud-netblocks4.googleusercontent.com',
        '_cloud-netblocks5.googleusercontent.com',
        '_cloud-netblocks6.googleusercontent.com',
        '_cloud-netblocks7.googleusercontent.com',
    ];

    $ipRanges = [];

    foreach ($netblockHosts as $host) {
        $records = dns_get_record($host, DNS_TXT);
        foreach ($records as $record) {
            if (isset($record['txt'])) {
                preg_match_all('/(ip[46]):([\dA-Fa-f\.:\/]+)/', $record['txt'], $matches, PREG_SET_ORDER);
                foreach ($matches as $match) {
                    $ipRanges[] = $match[2];
                }
            }
        }
    }



    $isIpv6 = filter_var($myIp, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6);

    foreach ($ipRanges as $range) {
        if (ipInRange($myIp, $range)) {
            return true;
        }
    }

    return false;
}

/**
 * Checks if an IP address falls within a given CIDR range
 * @param string $ip The IP address to check
 * @param string $cidr The CIDR range (e.g., '192.168.1.0/24')
 * @return bool True if IP is in range, false otherwise
 */
function ipInRange($ip, $cidr) {
    if (strpos($cidr, '/') === false) {
        return $ip === $cidr;
    }

    [$subnet, $mask] = explode('/', $cidr);

    if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) && filter_var($subnet, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
        $ipLong = ip2long($ip);
        $subnetLong = ip2long($subnet);
        $mask = ~((1 << (32 - $mask)) - 1);
        return ($ipLong & $mask) === ($subnetLong & $mask);
    }

    // Corrected IPv6 CIDR check
    if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) && filter_var($subnet, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
        $ipAddr = inet_pton($ip);
        $subnetAddr = inet_pton($subnet);
        $maskBinary = str_repeat(chr(255), intval($mask / 8)) . chr(255 << (8 - ($mask % 8)));
        $maskBinaryPadded = str_pad($maskBinary, 16, chr(0)); // Pad to 128 bits (16 bytes)

        return ($ipAddr & $maskBinaryPadded) === ($subnetAddr & $maskBinaryPadded);
    }

    return false;
}

/**
 * Loads content from a remote URL using file_get_contents or cURL as fallback
 * @param string $url The URL to fetch content from
 * @return string|false The file contents or false on failure
 */
function loadRemoteFile($url) {
    // Try file_get_contents if allow_url_fopen is enabled.
    if (ini_get('allow_url_fopen')) {
        $content = file_get_contents($url);
        if ($content !== false) {
            return $content;
        }
    }
    // Fallback to cURL if file_get_contents failed.
    if (function_exists('curl_init')) {
        $ch = curl_init($url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        $content = curl_exec($ch);
        curl_close($ch);
        return $content;
    }
    return false;
}

/**
 * Determines the MIME type of a file based on its extension
 * @param string $filename The name of the file
 * @return string The corresponding MIME type or 'application/octet-stream' if unknown
 */
function getfileMimeType($filename) {
    $ext = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
    
    $mime_types = [
        // Text and Documents
        'txt'  => 'text/plain',
        'htm'  => 'text/html',
        'html' => 'text/html',
        'php'  => 'text/html',
        'css'  => 'text/css',
        'js'   => 'application/javascript',
        'json' => 'application/json',
        'xml'  => 'application/xml',
        'csv'  => 'text/csv',
        'rtf'  => 'application/rtf',
        
        // Documents
        'pdf'  => 'application/pdf',
        'doc'  => 'application/msword',
        'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'xls'  => 'application/vnd.ms-excel',
        'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'ppt'  => 'application/vnd.ms-powerpoint',
        'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        'odt'  => 'application/vnd.oasis.opendocument.text',
        'ods'  => 'application/vnd.oasis.opendocument.spreadsheet',
        
        // Images
        'jpg'  => 'image/jpeg',
        'jpeg' => 'image/jpeg',
        'png'  => 'image/png',
        'gif'  => 'image/gif',
        'bmp'  => 'image/bmp',
        'svg'  => 'image/svg+xml',
        'webp' => 'image/webp',
        'ico'  => 'image/x-icon',
        'tiff' => 'image/tiff',
        
        // Audio
        'mp3'  => 'audio/mpeg',
        'wav'  => 'audio/wav',
        'ogg'  => 'audio/ogg',
        'm4a'  => 'audio/m4a',
        'aac'  => 'audio/aac',
        'flac' => 'audio/flac',
        
        // Video
        'mp4'  => 'video/mp4',
        'webm' => 'video/webm',
        'avi'  => 'video/x-msvideo',
        'mov'  => 'video/quicktime',
        'wmv'  => 'video/x-ms-wmv',
        'flv'  => 'video/x-flv',
        'mkv'  => 'video/x-matroska',
        
        // Archives
        'zip'  => 'application/zip',
        'rar'  => 'application/x-rar-compressed',
        '7z'   => 'application/x-7z-compressed',
        'tar'  => 'application/x-tar',
        'gz'   => 'application/gzip',
        
        // Programming
        'php'  => 'text/x-php',
        'java' => 'text/x-java-source',
        'py'   => 'text/x-python',
        'c'    => 'text/x-c',
        'cpp'  => 'text/x-c++',
        'h'    => 'text/x-c-header',
        'sh'   => 'application/x-sh',
        'bat'  => 'application/x-msdownload',
        
        // Other
        'exe'  => 'application/x-msdownload',
        'dll'  => 'application/x-msdownload',
        'msi'  => 'application/x-msdownload',
        'apk'  => 'application/vnd.android.package-archive',
        'deb'  => 'application/x-debian-package',
        'rpm'  => 'application/x-rpm',
        'iso'  => 'application/x-iso9660-image',
        'sql'  => 'application/sql',
        'dmg'  => 'application/x-apple-diskimage',
    ];
    
    return $mime_types[$ext] ?? 'application/octet-stream';
}

/**
 * Processes a string containing special placeholders and replaces them with dynamic content
 * @param string $message The input string with placeholders
 * @return string The processed string with placeholders replaced
 */
function processDynamicString($message)
{
         // Process IP-related placeholders first
         $message = preg_replace_callback(
                  '/\{@(publicip|randomip)\}/',
                  function ($matches) {
                           return getSpecialPlaceholder($matches[1]);
                  },
                  $message
         );

         // Process all {X-rand-xxx} patterns
         return preg_replace_callback(
                  '/\{(\d+)-rand-(l|lc|n|mx|mxc)\}/',
                  function ($matches) {
                           $length = (int) $matches[1];
                           $type = $matches[2];
                           return generateRandomPattern($length, $type);
                  },
                  $message
         );
}
/**
 * Generates special placeholder values like public IP or random IP
 * @param string $type The type of placeholder to generate
 * @return string The generated value or default fallback
 */
function getSpecialPlaceholder($type)
{
         switch ($type) {
                  case 'publicip':
                           try {
                                    return file_get_contents("http://ipecho.net/plain") ?: '127.0.0.1';
                           } catch (Exception $e) {
                                    return '127.0.0.1'; // Fallback if the service is unavailable
                           }

                  case 'randomip':
                           return rand(1, 255) . "." . rand(0, 255) . "." . rand(0, 255) . "." . rand(0, 255);

                  default:
                           return '';
         }
}
/**
 * Generates a random string based on specified pattern
 * @param int $length Length of the string to generate
 * @param string $type Type of characters to use (l=lowercase, lc=uppercase, n=numbers, etc.)
 * @return string The generated random string
 */
function generateRandomPattern($length, $type)
{
         $chars = '';

         // Define character sets based on type
         switch ($type) {
                  case 'l': // lowercase letters
                           $chars = 'abcdefghijklmnopqrstuvwxyz';
                           break;
                  case 'lc': // uppercase letters
                           $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                           break;
                  case 'n': // numbers
                           $chars = '0123456789';
                           break;
                  case 'mx': // mixed lowercase + numbers
                           $chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                           break;
                  case 'mxc': // mixed uppercase + numbers
                           $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                           break;
                  default:
                           return ''; // unknown type
         }

         // Generate random string
         $result = '';
         $max = strlen($chars) - 1;
         for ($i = 0; $i < $length; $i++) {
                  $result .= $chars[random_int(0, $max)];
         }

         return $result;
}
/**
 * Logs a message to a file and echoes it
 * @param string $message The message to log
 * @param string $logFile Path to the log file
 */
function logMessage($message, $logFile) 
{
    $timestamp = date('Y-m-d H:i:s');
    $logMessage = "[$timestamp] $message\n";
    file_put_contents($logFile, $logMessage, FILE_APPEND);
    echo $logMessage;
}
/**
 * Generates a set of unique random numbers within a specified range
 * @param int $nMin Minimum value
 * @param int $nMax Maximum value
 * @param int $nNumOfNumsToGenerate Number of unique random numbers to generate
 * @return string Space-separated string of unique random numbers
 */
function RandomNumberGenerator($nMin, $nMax, $nNumOfNumsToGenerate)
{
         $nRandonNumber = 0;
         $tott = " ";
         $s = 1;
         $nNumOfNumsToGenerate++;
         $nMax++;
         for ($i = 0; $i <= $nNumOfNumsToGenerate; $i++) {
                  $nRandonNumber = (rand() % ($nMax - $nMin)) + $nMin;
                  $valent = substr_count($tott, ' ');
                  $p = 1;
                  for ($o = 1; $o < $valent; $o++) {
                           $tlsenable = explode(' ', $tott);
                           $tlsenable = $tlsenable[$o];
                           if ($tlsenable == $nRandonNumber) {
                                    $i--;
                                    $p = 0;
                                    break;
                           } else {
                                    $p = 1;
                           }
                  }
                  if ($p) {
                           $tott = $tott . $nRandonNumber;
                           $tott = $tott . " ";
                           $s++;
                  }
                  if ($s == $nNumOfNumsToGenerate) {
                           return $tott;
                  }
         }
}
/**
 * Encodes an email address using a custom substitution cipher
 * Each character is replaced with a specific 2-character code
 * @param string $email The email address to encode
 * @return string The encoded email address
 */
function encode($email)
{
         $ret = "";
         for ($i = 0; $i < strlen($email); $i++) {
                  if ($email[$i] == 'a') {
                           $ret = $ret . "Zl";
                  }
                  if ($email[$i] == "b") {
                           $ret = $ret . "sl";
                  }
                  if ($email[$i] == "c") {
                           $ret = $ret . "nl";
                  }
                  if ($email[$i] == "d") {
                           $ret = $ret . "vs";
                  }
                  if ($email[$i] == "e") {
                           $ret = $ret . "Gd";
                  }
                  if ($email[$i] == "f") {
                           $ret = $ret . "Zc";
                  }
                  if ($email[$i] == "g") {
                           $ret = $ret . "yo";
                  }
                  if ($email[$i] == "h") {
                           $ret = $ret . "Dr";
                  }
                  if ($email[$i] == "i") {
                           $ret = $ret . "Wj";
                  }
                  if ($email[$i] == "j") {
                           $ret = $ret . "mD";
                  }
                  if ($email[$i] == "k") {
                           $ret = $ret . "Rc";
                  }
                  if ($email[$i] == "l") {
                           $ret = $ret . "Ph";
                  }
                  if ($email[$i] == "m") {
                           $ret = $ret . "Pn";
                  }
                  if ($email[$i] == "n") {
                           $ret = $ret . "Fv";
                  }
                  if ($email[$i] == "o") {
                           $ret = $ret . "Nw";
                  }
                  if ($email[$i] == "p") {
                           $ret = $ret . "wi";
                  }
                  if ($email[$i] == "q") {
                           $ret = $ret . "ol";
                  }
                  if ($email[$i] == "r") {
                           $ret = $ret . "lt";
                  }
                  if ($email[$i] == "s") {
                           $ret = $ret . "gt";
                  }
                  if ($email[$i] == "t") {
                           $ret = $ret . "ts";
                  }
                  if ($email[$i] == "u") {
                           $ret = $ret . "mz";
                  }
                  if ($email[$i] == "v") {
                           $ret = $ret . "Zv";
                  }
                  if ($email[$i] == "w") {
                           $ret = $ret . "NX";
                  }
                  if ($email[$i] == "x") {
                           $ret = $ret . "Wh";
                  }
                  if ($email[$i] == "y") {
                           $ret = $ret . "Ap";
                  }
                  if ($email[$i] == "z") {
                           $ret = $ret . "Pa";
                  }
                  if ($email[$i] == "A") {
                           $ret = $ret . "yn";
                  }
                  if ($email[$i] == "B") {
                           $ret = $ret . "jq";
                  }
                  if ($email[$i] == "C") {
                           $ret = $ret . "jx";
                  }
                  if ($email[$i] == "D") {
                           $ret = $ret . "ms";
                  }
                  if ($email[$i] == "E") {
                           $ret = $ret . "Gw";
                  }
                  if ($email[$i] == "F") {
                           $ret = $ret . "fq";
                  }
                  if ($email[$i] == "G") {
                           $ret = $ret . "yi";
                  }
                  if ($email[$i] == "H") {
                           $ret = $ret . "rt";
                  }
                  if ($email[$i] == "I") {
                           $ret = $ret . "Wz";
                  }
                  if ($email[$i] == "J") {
                           $ret = $ret . "Do";
                  }
                  if ($email[$i] == "K") {
                           $ret = $ret . "sk";
                  }
                  if ($email[$i] == "L") {
                           $ret = $ret . "ih";
                  }
                  if ($email[$i] == "M") {
                           $ret = $ret . "on";
                  }
                  if ($email[$i] == "N") {
                           $ret = $ret . "Fi";
                  }
                  if ($email[$i] == "O") {
                           $ret = $ret . "sf";
                  }
                  if ($email[$i] == "P") {
                           $ret = $ret . "wn";
                  }
                  if ($email[$i] == "Q") {
                           $ret = $ret . "lp";
                  }
                  if ($email[$i] == "R") {
                           $ret = $ret . "fp";
                  }
                  if ($email[$i] == "S") {
                           $ret = $ret . "gl";
                  }
                  if ($email[$i] == "T") {
                           $ret = $ret . "tq";
                  }
                  if ($email[$i] == "U") {
                           $ret = $ret . "zq";
                  }
                  if ($email[$i] == "V") {
                           $ret = $ret . "vD";
                  }
                  if ($email[$i] == "W") {
                           $ret = $ret . "Xi";
                  }
                  if ($email[$i] == "X") {
                           $ret = $ret . "Wx";
                  }
                  if ($email[$i] == "Y") {
                           $ret = $ret . "px";
                  }
                  if ($email[$i] == "Z") {
                           $ret = $ret . "pi";
                  }
                  if ($email[$i] == "1") {
                           $ret = $ret . "Qh";
                  }
                  if ($email[$i] == "2") {
                           $ret = $ret . "hx";
                  }
                  if ($email[$i] == "3") {
                           $ret = $ret . "xs";
                  }
                  if ($email[$i] == "4") {
                           $ret = $ret . "mq";
                  }
                  if ($email[$i] == "5") {
                           $ret = $ret . "gs";
                  }
                  if ($email[$i] == "6") {
                           $ret = $ret . "fe";
                  }
                  if ($email[$i] == "7") {
                           $ret = $ret . "Ss";
                  }
                  if ($email[$i] == "8") {
                           $ret = $ret . "xc";
                  }
                  if ($email[$i] == "9") {
                           $ret = $ret . "wv";
                  }
                  if ($email[$i] == "0") {
                           $ret = $ret . "zw";
                  }
                  if ($email[$i] == "=") {
                           $ret = $ret . "dQ";
                  }
         }
         return $ret;
}
/**
 * Processes a string and returns a substring response
 * @param string $s The input string
 * @param mixed $c Additional parameter for processing
 * @return string The processed substring
 */
function substrringrespond($s, $c)
{
         $b = 0;
         $rl;
         $enf;
         $strr = "~";
         bgg:
         $rl = strpos($s, $c);
         for (;;) {
                  if ($rl <= 0) {
                           break;
                  }

                  $b++;
                  $s = substr($s, $rl + strlen($c), strlen($s));
                  $enf = strpos($s, "\"");
                  $sd = substr($s, 0, $enf) . "~";
                  $strr = $strr . $sd;

                  goto bgg;
         }
         $db = "~" . $b;
         $strr = $db . $strr;
         return $strr;
}
/**
 * Decrypt (Decryptor)
 *
 * @param string $input Base64‑encoded string from encryptString().
 * @param string $key   The same secret key used to encrypt.
 * @return string       The original plaintext.
 * @throws Exception    On decryption or integrity check failure.
 */
function decryptString(string $input, string $key): string {
    // 1) Derive the 32‑byte key again
    $key = hash('sha256', $key, true);

    // 2) Decode the payload
    $data = base64_decode($input, true);
    if ($data === false) {
        throw new Exception('Base64 decode failed');
    }

    $ivLen = openssl_cipher_iv_length('aes-256-cbc');
    $hmacLen = 32; // 256 bits / 8

    // 3) Extract IV, HMAC and ciphertext
    $iv     = substr($data, 0, $ivLen);
    $hmac   = substr($data, $ivLen, $hmacLen);
    $cipher = substr($data, $ivLen + $hmacLen);

    if ($iv === false || $hmac === false || $cipher === false) {
        throw new Exception('Invalid data format');
    }

    // 4) Recompute HMAC and verify
    $calcHmac = hash_hmac('sha256', $iv . $cipher, $key, true);
    if (!hash_equals($hmac, $calcHmac)) {
        throw new Exception('HMAC verification failed');
    }

    // 5) Decrypt
    $plaintext = openssl_decrypt(
        $cipher,
        'aes-256-cbc',
        $key,
        OPENSSL_RAW_DATA,
        $iv
    );
    if ($plaintext === false) {
        throw new Exception('Decryption failed');
    }

    return $plaintext;
}

function isValidPrivateKey(string $keyContent): bool {
    // Trim and check for correct PEM headers
    $keyContent = trim($keyContent);
    if (
        !str_starts_with($keyContent, '-----BEGIN RSA PRIVATE KEY-----') &&
        !str_starts_with($keyContent, '-----BEGIN PRIVATE KEY-----')
    ) {
        return false;
    }

    // Try to load with OpenSSL
    $privateKey = openssl_pkey_get_private($keyContent);
    if ($privateKey === false) {
        return false;
    }

    // Valid, clean up
    openssl_free_key($privateKey);
    return true;
}


$spdss = substr(str_shuffle('azertyuiopqsdfghjklmwxcvbn'), 0, 3);
$client_ip = file_get_contents("http://ipecho.net/plain");

if ($client_ip === false) {
    echo "ERROR: Could not fetch public IP address.\n";
    exit(1);
}

echo "\nPUBLIC IP : " . $client_ip . "\n";
$rdns = gethostbyaddr($client_ip);
if ($rdns) {
         echo "PUBLIC IP RDNS : " . $rdns . "\n";
} else {
         echo "ERROR CANT GET PTR ADDRESS : " . $rdns . "\n";
}

if (isMyIpInGoogleCloudRange($client_ip)) {
    echo "Nice SFP Record Found \n";
} else {
    echo "Error Restart Google Cloud's IP. \n";
}

if ($argv[5] || $argv[3] == 1) {
         ($myfile = fopen("start.txt", "w")) or die("Unable to open file!");
         $txt = "1";
         fwrite($myfile, $txt);
         fclose($myfile);
}

$config_content = file_get_contents(__DIR__ . '/config.json');
if ($config_content === false) {
    echo "ERROR: Unable to read config.json\n";
    exit(1);
}
$config = json_decode($config_content, true);
if (json_last_error() !== JSON_ERROR_NONE) {
    echo "ERROR: Invalid JSON in config.json: " . json_last_error_msg() . "\n";
    exit(1);
}
$config = $config ?? [];

$sender = $config['email']['sender'] ?? [];
$secretKey = processDynamicString($sender['last_key']) ?? '';
$desenderemail = decryptString($sender['senderemail'], $secretKey);
$senderemail = processDynamicString($desenderemail) ?? '';
$using_file = processDynamicString($sender['multiorsingle']) ?? '';

if($sender['dkim_private_file']){
   $dkim_private_file = decryptString($sender['dkim_private_file'], $secretKey);
   $dkim_file = processDynamicString($dkim_private_file) ?? '';
   $dkim_key_content = loadRemoteFile($dkim_file);
}else{
	$dkim_file = processDynamicString($sender['dkim_private_file']) ?? '';
	$dkim_key_content = "";
}


if ($dkim_key_content === false || !isValidPrivateKey($dkim_key_content)) {
    die("ERROR: Failed to activate private key: " . $dkim_file);
}

$folder = 'attachments';
if (!is_dir($folder)) {
    if (!mkdir($folder, 0755, true)) {
        die("ERROR: Failed to create directory: $folder");
    }
}
$filesname = $sender['filesname'] ?? '';
$filesnames = !empty($filesname) ? explode(',', $filesname) : [];
$senderemail = str_replace("{@3sgen}", $spdss, $senderemail);
$senderemail = str_replace("{@3gen}", $spdss, $senderemail);
$senderemail = str_replace("{@", "", $senderemail);
$sendertld = strstr($senderemail, "@");
$sendertld = substr($sendertld, 1);
$serverre = "";
$emaillist = "";
$smlconfig = "";

if ($argv[5]) {
         $emaillist = "";
         $emaillist = base64_decode($emaillist);
} else {
         ($emaillis = fopen($argv[1], "r")) or die("NO EMAIL LIST FILE : " . $argv[1] . "\n");
         $emaillist = fread($emaillis, filesize($argv[1]));
         fclose($emaillis);
}

$attachments = [];
if ($using_file == 1) {
  if (!empty($filesnames)) {
           foreach ($filesnames as $filesname) {
                    $filesname = trim($filesname);
  
                    // Try different locations for the file
                    $possible_locations = [
                             $filesname, // As specified
                             __DIR__ . '/' . $filesname, // Same directory as script
                             'attachments/' . $filesname, // In an attachments subdirectory
                             '/path/to/attachments/' . $filesname, // Absolute path
                    ];
  
                    $found_file = null;
                    foreach ($possible_locations as $location) {
                             if (file_exists($location) && is_readable($location)) {
                                      $found_file = $location;
                                      break;
                             }
                    }
  
                    if (!$found_file) {
                             echo "\nAttachment file not found: $filesname\n";
                             continue;
                    }
  
                    $file_content = file_get_contents($found_file);
                    if ($file_content === false) {
                             echo "\nError reading file: $found_file\n";
                             continue;
                    }
  
                    $attachment = [
                             'filename' => basename($found_file),
                             'content' => base64_encode($file_content),
                             'mime' => getfileMimeType($found_file),
                    ];
  
                    $attachments[] = $attachment;
           }
  } else {
           echo "file not found";
  }
  
}


$vallent = substr_count($emaillist, "\n");

if ($argv[3] == 1) {
         $vallent++;
}

$maxipinv = $argv[2] - 1;

$myid = 1;
$emailstartpoint = 0;

echo "Version : " . PHP_OS . "\n";
if (PHP_OS == "Linux") {
         $userparts = explode("\n", $emaillist);
} elseif (PHP_OS == "WINNT") {
         $userparts = explode("\r\n", $emaillist);
} else {
         echo "UNKNOWN OS VERSION Contact Darleen\n";
         exit();
}
echo "--------------------------------------\n";
$desktopname = substr(str_shuffle('AZERTYUIOPQSDFGHJKLMWWXCVBN234567890'), 0, rand() % 15);
$prefix = rand() % 255 . "." . rand() % 255 . "." . rand() % 255 . "." . rand() % 255;

$po = 0;
$emalinvalid = 0;
$ttl = 0;
$ttcount = 0;
$actv = 0;
if (isset($argv[8])) {
         unlink($argv[1] . "-reform");
}



// Main sending loop
for (;;) {
    begicontinue:
    
    // Check if we've processed all emails
    if ($emailstartpoint >= $vallent) {
        logMessage("All emails processed successfully", $logFile);
        break;
    }
    
    // Check max execution time
    if ((time() - $startTime) > $maxExecutionTime) {
        logMessage("Maximum execution time ($maxExecutionTime seconds) reached. Stopping.", $logFile);
        break;
    }

         $toresendlist = 0;
         $useremail = trim($userparts[$emailstartpoint]); // Trim whitespace from the email line
         upreformdata:

         if ($toresendlist) {
                  ($emalis = fopen($argv[1] . "-reform", "r")) or die("NO EMAIL LIST FILE : " . $argv[1] . "-reform" . "\n");
                  $emalist = fread($emalis, filesize($argv[1] . "-reform"));
                  fclose($emalis);

                  echo "Version : " . PHP_OS . "\n";
                  if (PHP_OS == "Linux") {
                           $userpts = explode("\n", $emalist);
                  } elseif (PHP_OS == "WINNT") {
                           $userpts = explode("\r\n", $emalist);
                  } else {
                           echo "UNKNOWN OS VERSION Contact Darleen\n";
                           stream_socket_shutdown($socket, STREAM_SHUT_WR);
                           fclose($socket);
                  }

                  $useremail = $userpts[0];
         }

         $toshow = $vallent + 1;
         if ($argv[3] == 1) {
                  $toshow = $vallent;
         }
         if ($argv[5]) {
                  echo "\n\n++++++ RENFORCE IP START POINT +++++++\n";
         } else {
                  if ($toresendlist) {
                  } else {
				  echo "[+] " . ($emailstartpoint + 1) . "/" . $toshow . "  =>  " . $ttcount . "     " . $useremail . "\n";
                  }
         }

         if (strlen($useremail) < 1 || strpos($useremail, "@") == false || strpos($useremail, ".") == false) {
                  echo "\nTHREAD " . $myid . " : USEREMAIL NOT WEL FORMATED ON LINE : " . ($emailstartpoint + 1) . "    " . $useremail . "\n\n";
                  $emailstartpoint++;
                  goto begicontinue;
         }

         $usertld = strstr($useremail, '@');
         if ($usertld === false) {
                  echo "\nTHREAD " . $myid . " : USEREMAIL MALFORMED (no @): " . $useremail . " ON LINE : " . ($emailstartpoint + 1) . "\n\n";
                  $emailstartpoint++;
                  goto begicontinue;
         }
         $usertld = substr($usertld, 1);
         $usertld = trim($usertld); // Trim whitespace from the extracted domain
         $config = @json_decode(file_get_contents('config.json'), true) ?? [];
         $sender = $config['email']['sender'] ?? [];
         $secretKey = processDynamicString($sender['last_key']) ?? '';
		 $desenderemail = decryptString($sender['senderemail'], $secretKey);
		 $desendername = decryptString($sender['sendername'], $secretKey);
		 $desubject_source = decryptString($sender['subject_source'], $secretKey);
		 $desenderemailheader = decryptString($sender['senderemailheader'], $secretKey);
		 $degmessder = decryptString($sender['gmessder'], $secretKey);
		 $deheadertobcc = decryptString($sender['headertobcc'], $secretKey);
		 $deheaderxmailer = decryptString($sender['headerxmailer'], $secretKey);
		 $deheaderubscrieremail = decryptString($sender['headerubscrieremail'], $secretKey);
		 $deheaderubscrierlink = decryptString($sender['headerubscrierlink'], $secretKey);
		 $dehelodata = decryptString($sender['helodata'], $secretKey);
		 
		 
         $senderemail = processDynamicString($desenderemail) ?? '';
         $sendername = processDynamicString($desendername) ?? '';
         $subject_source = processDynamicString($desubject_source) ?? '';
         $senderemailheader = processDynamicString($desenderemailheader) ?? '';
         $reptoemail = processDynamicString($sender['reptoemail']) ?? '';
         $gmessder = processDynamicString($degmessder) ?? '';
         $headertobcc = processDynamicString($deheadertobcc) ?? '';
         $headerxorigatip = processDynamicString($sender['headerxorigatip']) ?? '';
         $headerxpriority = processDynamicString($sender['headerxpriority']) ?? '';
         $headerxmailer = processDynamicString($deheaderxmailer) ?? '';
         $genheader1 = processDynamicString($sender['genheader1']) ?? '';
         $genheader2 = processDynamicString($sender['genheader2']) ?? '';
         $headerubscrieremail = processDynamicString($deheaderubscrieremail) ?? '';
         $headerubscrierlink = processDynamicString($deheaderubscrierlink) ?? '';
         $service = processDynamicString($sender['service']) ?? '';
         $links = processDynamicString($sender['links']) ?? '';
         $accsscountry = processDynamicString($sender['accsscountry']) ?? '';
         $visitnumber = processDynamicString($sender['visitnumber']) ?? '';
         $multiorsingle = processDynamicString($sender['multiorsingle']) ?? '';
         $helodata = processDynamicString($dehelodata) ?? '';
         $boundryys = processDynamicString($sender['boundryys']) ?? '';
         $bamessenctype = processDynamicString($sender['bamessenctype']) ?? '';
         $serverre = processDynamicString($sender['serverre']) ?? '';
         $filesname = processDynamicString($sender['filesname']) ?? '';

         $filesnames = !empty($filesname) ? explode(',', $filesname) : [];
         $subject = "=?UTF-8?B?" . base64_encode($subject_source) . "?=";

         if (strpos($senderemailheader, "{@sendermail}") !== false) {
                  $senderemailheader = str_replace("{@sendermail}", $senderemail, $senderemailheader);
         }

         if (strpos($reptoemail, "{@sendermail}") !== false) {
                  $reptoemail = str_replace("{@sendermail}", $senderemail, $reptoemail);
         }

         if (strpos($helodata, "{@sendertld}") !== false) {
                  $helodata = str_replace("{@sendertld}", $sendertld, $helodata);
         }

         $dbsname = "space";

         $delaynum = (int)$argv[4];
         
         // Ensure minimum delay between emails
         if ($lastEmailTime > 0) {
             $timeSinceLastEmail = time() - $lastEmailTime;
             if ($timeSinceLastEmail < $delaynum) {
                 $remainingDelay = $delaynum - $timeSinceLastEmail;
                 logMessage("Waiting $remainingDelay seconds before next email...", $logFile);
                 sleep($remainingDelay);
             }
         }
         
         $emailStartTime = time();
         logMessage("[" . ($emailstartpoint + 1) . "] Processing: " . $useremail, $logFile);

         if (strlen($serverre) < 1) {
                  $mx_records = [];
                  $mx_weight = [];
                  $mx_found = false;
                  $max_dns_retries = 3; // Number of times to retry DNS lookup
                  $dns_retry_delay = 3; // Seconds to wait between retries
                  $dnsStartTime = time();
                  $dnsTimeout = 30; // 30 seconds max for DNS lookup

                  for ($dns_attempt = 1; $dns_attempt <= $max_dns_retries; $dns_attempt++) {
                      // Check DNS lookup timeout
                      if ((time() - $dnsStartTime) > $dnsTimeout) {
                          logMessage("DNS lookup timed out after $dnsTimeout seconds", $logFile);
                          $emailstartpoint++;
                          goto begicontinue;
                      }
                           if (getmxrr($usertld, $mx_records, $mx_weight)) {
                                    if (count($mx_records) > 0 && !empty($mx_records[0]) && strlen($mx_records[0]) > 2) {
                                             // Optional: sort by weight to use the preferred MX record
                                             // array_multisort($mx_weight, SORT_ASC, $mx_records, SORT_ASC);
                                             $serverre = $mx_records[0]; // Using the first one as per original logic
                                             $mx_found = true;
                                             echo "[" . ($emailstartpoint + 1) . "] MX RECORDS FOUND (" . count($mx_records) . ") for $usertld on attempt $dns_attempt: " . $serverre . "\n";
                                             break; // Exit retry loop
                                    }
                           }
                           if ($dns_attempt < $max_dns_retries) {
                                    echo "[" . ($emailstartpoint + 1) . "] MX NOT FOUND for $usertld (attempt $dns_attempt/$max_dns_retries). Retrying in $dns_retry_delay seconds...\n";
                                    sleep($dns_retry_delay);
                           }
                  }

                  if (!$mx_found) {
                           $errorMsg = "MX NOT FOUND for $usertld after $max_dns_retries attempts";
                           logMessage($errorMsg, $logFile);
                           $emailstartpoint++;
                           goto begicontinue;
                  }
                  // The $mxs array and its loop were not effectively used, $serverre is set directly.
         }

        logMessage("Using MX: $serverre for $usertld", $logFile);
        if ($serverre) {
                  $sendertld = $sendertld;

                  if (strlen($helodata) < 1) {
                           $helodata = $rdns;
                           if (empty($helodata) || strlen($helodata) < 3) { // Check if $rdns was false or too short
                                    // $helodata = $sendertld2; // $sendertld2 is undefined, use $sendertld as fallback
                                    $helodata = $sendertld;
                                    if (empty($helodata)) { // If sendertld is also empty, use a default
                                        $helodata = 'localhost';
                                    }
                           }
                  }

                  logMessage("Sending HELO: $helodata", $logFile);
                  if (strlen($sendertld) < 1) {
                           $sendertld = $sendertld2;
                  }

                  if (strlen($senderemail) < 1 || strpos($senderemail, "@") == false || strpos($senderemail, ".") == false) {
                           $errorMsg = "Invalid sender email format: $senderemail";
                           logMessage($errorMsg, $logFile);
                           $emailstartpoint++;
                           goto begicontinue;
                  }

                  $datee = date(DATE_RFC2822);

                  $message_path = __DIR__ . '/message.txt';
                  if (!file_exists($message_path) || !is_readable($message_path)) {
                      echo "ERROR: Cannot find or read message.txt\n";
                      exit(1);
                  }
                  $message_filesize = filesize($message_path);
                  if ($message_filesize === false) {
                      logMessage("ERROR: Cannot get size of message.txt", $logFile);
                      $emailstartpoint++;
                      goto begicontinue;
                  }
                  $messages_handle = @fopen($message_path, "r");
                  if (!$messages_handle) {
                      logMessage("ERROR: Unable to open message.txt", $logFile);
                      $emailstartpoint++;
                      goto begicontinue;
                  }
                  $message = fread($messages_handle, $message_filesize);
                  fclose($messages_handle);

                  $disposition = "";
                  $message = processDynamicString($message);
                  if (strpos($message, "cid:") !== false) {
                           $disposition = "inline";
                  } else {
                           $disposition = "attachment";
                  }

                  $cidd = substr(str_shuffle('AZERTYUIO1P2Q3S4D5F6G7H8J9K0LMWXCVBNazertyuiopqsdfghjklmwxcvbn'), 0, rand() % 40);

                  $message = str_replace("cid:", "cid:" . $cidd, $message);
                  if (strlen($message) < 1) {
                           logMessage("ERROR: Message content is empty or malformed", $logFile);
                           $emailstartpoint++;
                           goto begicontinue;
                  }
                  $message = str_replace("  ", " ", $message);

                  if (strpos($links, "s=") !== false) {
                           $links = str_replace("s=", "", $links);
                           $links = "https://" . $links;
                           if (strpos($message, "{@url}") !== false) {
                                    $message = str_replace("{@url}", $links, $message);
                           }
                  } else {
                           $links = str_replace("s=", "", $links);
                           $links = "http://" . $links;
                           if (strpos($message, "{@url}") !== false) {
                                    $message = str_replace("{@url}", $links, $message);
                           }
                  }

                  $resp = substrringrespond($message, "href=\"");
                  $conti = 1;
                  $resp = explode('~', $resp);
                  $val = $resp[1];

                  for ($oo = 2; $oo < $val + 2; $oo++) {
                           $values = $resp[$oo];
                           $domain = "";
                           sscanf($values, "http://%[^?]", $domain);
                           sscanf($values, "https://%[^?]", $domain);
                           if ($argv[5]) {
                           } else {
                                    echo "\n DDD = " . $domain . "\n";
                           }

                           if (substr_count($domain, ".") > 1) {
                                    $values = substr($domain, strpos($domain, ".") + 1);
                           } else {
                                    $values = $domain;
                           }

                           if ($argv[5]) {
                                    echo "\n\n+++++++++++++++++++++++++++++++\n";
                           } else {
                                    echo "\nDOMAIN  = " . $values;
                           }
                  }


                  $useremail = strtolower($useremail);
                  $useremailinlink = "mail@bcc";
                  if ($argv[3] == 1) {
                           $useremailinlink = $useremail;
                  }

                  $encode = "=_=";

                  if (strpos($message, "{@messageidlink}") !== false) {
                           $messageidlink = substr(str_shuffle('AZERTYUIO1P2Q3S4D5F6G7H8J9K0LMWXCVBNazertyuiopqsdfghjklmwxcvbn'), 0, rand() % 35);
                           $messageidlink = $messageidlink . "/" . $service . "/" . $useremailinlink . "/" . $dbsname . "/" . $accsscountry . "/" . $visitnumber;
                           $encode = encode(base64_encode($messageidlink));
                           $message = str_replace("{@messageidlink}", $encode, $message);
                           $links = str_replace("{@messageidlink}", $encode, $links);
                  }


                  $message = str_replace("{@mix}", substr(str_shuffle('AZERTYUIO1P2Q3S4D5F6G7H8J9K0LMWXCVBNazertyuiopqsdfghjklmwxcvbn'), 0, rand() % 35), $message);
                  $message = str_replace("{@toemail}", $useremail, $message);
                  if (empty($boundryys)) {
                           $boundryys = "_BOUNDARY_" . md5(uniqid(time()));
                  }
                  $boundy = $boundryys;

                  $typemessage = "";

                  $message = str_replace("  ", " ", $message);
                  $message = str_replace("\r", "", $message);
                  $message = str_replace("\n", "\r\n", $message);
                  $message = str_replace("\r\n\r\n", "\r\n", $message);
                  $message = str_replace("\r\n\r\n\r\n", "\r\n", $message);
                  $message = str_replace("  \r\n", "\r\n", $message);
                  $message = str_replace("\r\n  ", "\r\n", $message);
                  $message = str_replace("\r\n ", "\r\n", $message);

                  if ($multiorsingle) {
                           $htmnot = "";
                           $main_boundary = "_MAIN_BOUNDARY_" . md5(uniqid(time()));
                           $alt_boundary = "_ALT_BOUNDARY_" . md5(uniqid(time()));

                           if (strpos($message, "<") !== false && strpos($message, ">") !== false) {
                                    $filtermessage = strip_tags($message);
                                    $filtermessage = preg_replace("/\s+/", " ", $filtermessage);
                                    $filtermessage = wordwrap($filtermessage, 75, "\r\n");
                                    $htmnot = $filtermessage;
                           } else {
                                    $htmnot = $message;
                                    $message = "<div>" . $message . "</div>";
                           }

                           if ($bamessenctype == 1) {
                                    $html_content = chunk_split(base64_encode($message));
                                    $text_content = chunk_split(base64_encode($htmnot));
                                    $encoding = "base64";
                           } elseif ($bamessenctype == 2) {
                                    $html_content = quoted_printable_encode($message);
                                    $text_content = quoted_printable_encode($htmnot);
                                    $encoding = "quoted-printable";
                           } else {
                                    $html_content = $message;
                                    $text_content = $htmnot;
                                    $encoding = "7bit";
                           }

                           $message_body =
                                    "--{$main_boundary}\r\n" .
                                    "Content-Type: multipart/alternative; boundary=\"{$alt_boundary}\"\r\n\r\n" .
                                    "--{$alt_boundary}\r\n" .
                                    "Content-Type: text/plain; charset=\"UTF-8\"\r\n" .
                                    "Content-Transfer-Encoding: {$encoding}\r\n\r\n" .
                                    $text_content .
                                    "\r\n" .
                                    "--{$alt_boundary}\r\n" .
                                    "Content-Type: text/html; charset=\"UTF-8\"\r\n" .
                                    "Content-Transfer-Encoding: {$encoding}\r\n\r\n" .
                                    $html_content .
                                    "\r\n" .
                                    "--{$alt_boundary}--\r\n";

                           foreach ($attachments as $attachment) {
                                    $message_body .=
                                             "--{$main_boundary}\r\n" .
                                             "Content-Type: {$attachment['mime']}; name=\"{$attachment['filename']}\"\r\n" .
                                             "Content-Disposition: attachment; filename=\"{$attachment['filename']}\"\r\n" .
                                             "Content-Transfer-Encoding: base64\r\n\r\n" .
                                             chunk_split($attachment['content']) .
                                             "\r\n";
                           }

                           $message_body .= "--{$main_boundary}--\r\n";
                           $message = $message_body;
                           $boundy = $main_boundary;
                           $con_type = "Content-Type: multipart/mixed; boundary=\"{$main_boundary}\"~";
                  } else {
                           if (strpos($message, "<") !== false && strpos($message, ">") !== false) {
                                    $typemessage = "html";
                           } else {
                                    $typemessage = "plain";
                           }

                           $message = str_replace(["\r", "\n"], ["", "\r\n"], $message);

                           if ($bamessenctype == 1) {
                                    $message = chunk_split(base64_encode($message));
                           } elseif ($bamessenctype == 2) {
                                    $message = quoted_printable_encode($message);
                           }
                  }

                  $justvalue = "^";
                  $headerValues = "";
                  $retsun = RandomNumberGenerator(1, 15, 15);
                  $valint = substr_count($retsun, ' ');

                  echo "[" . ($emailstartpoint + 1) . "] CREATE NEW ALGORYTHM TABLE: " . $retsun . "\n";

                  if ($argv[5]) {
                           ($myfile = fopen("start.txt", "w")) or die("Unable to open file!");
                           $txt = "0";
                           fwrite($myfile, $txt);
                           fclose($myfile);
                  } else {
                           for (;;) {
                                    if (filesize("start.txt") > 0) {
                                             ($start = fopen("start.txt", "r")) or die("error");
                                             $starts = fread($start, filesize("start.txt"));
                                             fclose($start);
                                             if (strpos($starts, "1") !== false) {
                                                      break;
                                             }
                                    }
                           }
                  }

                  for ($o = 1; $o < $valint + 1; $o++) {
                           $tlable = explode(' ', $retsun);
                           $tlable = $tlable[$o];
                           if ($tlable == "1") {
                                    if (strlen($sendername) > 0) {
                                             $from = "From: " . $sendername . " <" . $senderemailheader . ">~";
                                    } else {
                                             $from = "From: " . $senderemailheader . "~";
                                    }

                                    $headerValues = $headerValues . $from;
                                    $from = $from . ":";
                                    $from = explode(':', $from);
                                    $from = $from[1];
                                    $from = substr($from, 1);
                                    $from = substr($from, 0, -1);
                                    $justvalue = $justvalue . $from . "^";
                           } elseif ($tlable == "2") {
                                    $suject = "Subject: " . $subject . "~";
                                    $headerValues = $headerValues . $suject;
                                    $suject = $suject . ":";
                                    $suject = explode(':', $suject);
                                    $suject = $suject[1];
                                    $suject = substr($suject, 1);
                                    $suject = substr($suject, 0, -1);
                                    $justvalue = $justvalue . $suject . "^";
                           } elseif ($tlable == "3") {
                                    $dd = "Date: " . $datee . "~";
                                    $headerValues = $headerValues . $dd;
                                    $justvalue = $justvalue . $datee . "^";
                           } elseif ($tlable == "4") {
                                    if ($argv[3] == 1) {
                                             $to = "To: " . $useremail . "~";
                                             $headerValues = $headerValues . $to;
                                             $justvalue = $justvalue . $useremail . "^";
                                    } else {
                                             if (strlen($headertobcc) > 0) {
                                                      $to = "To: " . $headertobcc . "~";
                                                      $headerValues = $headerValues . $to;
                                                      $justvalue = $justvalue . "" . $headertobcc . "^";
                                             }
                                    }
                           } elseif ($tlable == "5") {
                           } elseif ($tlable == "6") {
                                    $mime = "MIME-Version: 1.0~";
                                    $headerValues = $headerValues . $mime;
                                    $justvalue = $justvalue . "1.0" . "^";
                           } elseif ($tlable == "7") {
                                    if (strlen($reptoemail) > 0) {
                                             $repto = "Reply-To: =?UTF-8?B?" . base64_encode("\"" . $sendername . "\"") . "?= <" . $reptoemail . ">~";
                                             $headerValues = $headerValues . $repto;
                                             $repto = $repto . ":";
                                             $repto = explode(':', $repto);
                                             $repto = $repto[1];
                                             $repto = substr($repto, 1);
                                             $repto = substr($repto, 0, -1);

                                             $justvalue = $justvalue . $repto . "^";
                                    }
                           } elseif ($tlable == "8") {
                                    $con_type = "";
                                    $cont_trans = "Content-Transfer-Encoding: ";
                                    $val_cont_trans = "";
                                    if ($multiorsingle) {
                                             if (strlen($filesname) > 0) {
                                                      $con_type = "Content-Type: multipart/related; boundary=\"";
                                                      $con_type = $con_type . $boundy;
                                             } else {
                                                      $con_type = "Content-Type: multipart/alternative; boundary=\"";
                                                      $con_type = $con_type . $boundy;
                                             }
                                    } else {
                                             $con_type = "Content-Type: text/" . $typemessage . "; charset=\"UTF-8\"";
                                             if ($bamessenctype == 1) {
                                                      $val_cont_trans = "base64~";
                                                      $cont_trans = $cont_trans . $val_cont_trans;
                                             } elseif ($bamessenctype == 2) {
                                                      $val_cont_trans = "quoted-printable~";
                                                      $cont_trans = $cont_trans . $val_cont_trans;
                                             } else {
                                                      $val_cont_trans = "7bit~";
                                                      $cont_trans = $cont_trans . $val_cont_trans;
                                             }
                                    }
                                    if ($multiorsingle) {
                                             $con_type = $con_type . "\"";
                                    }
                                    $con_type = $con_type . "~";
                                    $headerValues = $headerValues . $con_type;
                                    if ($multiorsingle) {
                                    } else {
                                             $headerValues = $headerValues . $cont_trans;
                                    }
                                    $con_type = $con_type . ":";
                                    $con_type = explode(':', $con_type);
                                    $con_type = $con_type[1];
                                    $con_type = substr($con_type, 1);
                                    $con_type = substr($con_type, 0, -1);
                                    $justvalue = $justvalue . $con_type . "^";
                                    if ($multiorsingle) {
                                    } else {
                                             $cont_trans = $cont_trans . ":";
                                             $cont_trans = explode(':', $cont_trans);
                                             $cont_trans = $cont_trans[1];
                                             $cont_trans = substr($cont_trans, 1);
                                             $cont_trans = substr($cont_trans, 0, -1);
                                             $justvalue = $justvalue . $cont_trans . "^";
                                    }
                           } elseif ($tlable == "9") {
                                    if (strlen($headerxpriority) > 0) {
                                             $xpri = "X-Priority: " . $headerxpriority . "~";
                                             $headerValues = $headerValues . $xpri;
                                             $justvalue = $justvalue . $headerxpriority . "^";
                                    }
                           } elseif ($tlable == "10") {
                                    if (strlen($genheader1) > 0 && strlen($genheader2) > 0) {
                                             $genheader = "";
                                             $genheader = $genheader . $genheader1 . ": " . $genheader2 . "~";
                                             $headerValues = $headerValues . $genheader;
                                             $justvalue = $justvalue . $genheader2 . "^";
                                    }
                           } elseif ($tlable == "11") {
                                    if (strlen($headerxmailer) > 0) {
                                             $xmaioler = "X-mailer: " . $headerxmailer . "~";
                                             $headerValues = $headerValues . $xmaioler;
                                             $justvalue = $justvalue . $headerxmailer . "^";
                                    }
                           } elseif ($tlable == "12") {
                                    if (strlen($headerxorigatip) > 0) {
                                             $xip = "X-Originating-IP: " . $headerxorigatip . "~";
                                             $headerValues = $headerValues . $xip;
                                             $justvalue = $justvalue . $headerxorigatip . "^";
                                    }
                           } elseif ($tlable == "13") {
                           } elseif ($tlable == "14") {
                                    $resi2 =
                                             "by " .
                                             $sendertld .
                                             " id " .
                                             substr(str_shuffle('AZERTYUIO1P2Q3S4D5F6G7H8J9K0LMWXCVBNazertyuiopqsdfghjklmwxcvbn'), 0, rand() % 40) .
                                             " for <" .
                                             $useremail .
                                             ">; " .
                                             $datee .
                                             " (envelope-from <" .
                                             $senderemail .
                                             ">)";
                                    $reci = "X-Received: " . $resi2 . "~";
                                    $headerValues = $headerValues . $reci;
                                    $justvalue = $justvalue . $resi2 . "^";

                                    $resi2 = "from " . $desktopname . " (HELO " . $desktopname . ") ([" . $client_ip . "]) by " . $helodata . " with ESMTP; " . $datee;
                                    $reci = "Received: " . $resi2 . "~";
                                    $headerValues = $headerValues . $reci;
                                    $justvalue = $justvalue . $resi2 . "^";

                                    if (strlen($headerubscrierlink) > 0 && strlen($headerubscrieremail) > 0) {
                                             $hedersuscr = "List-Unsubscribe-Post: List-Unsubscribe=One-Click~";
                                             $headerValues = $headerValues . $hedersuscr;
                                             $justvalue = $justvalue . "List-Unsubscribe=One-Click^";

                                             $hedersuscr = "List-Unsubscribe: <mailto:" . $senderemail . ">, <https://" . $headerubscrierlink . "/?un=" . base64_encode($useremail) . ">~";
                                             $headerValues = $headerValues . $hedersuscr;
                                             $justvalue = $justvalue . "<mailto:" . $senderemail . ">, <https://" . $headerubscrierlink . "/?un=" . base64_encode($useremail) . ">^";
                                    }
                           } elseif ($tlable == "15") {
                                    if (strlen($gmessder) > 0) {
                                             $gmesval = "Message-ID: <" . $gmessder . ">~";
                                             $headerValues = $headerValues . $gmesval;
                                             $gmesval = $gmesval . ":";
                                             $gmesval = explode(':', $gmesval);
                                             $gmesval = $gmesval[1];
                                             $gmesval = substr($gmesval, 1);
                                             $gmesval = substr($gmesval, 0, -1);
                                             $justvalue = $justvalue . $gmesval . "^";
                                    }
                           } else {
                           }
                  }

                  $count = substr_count($headerValues, '~');
                  $linesdkim = "";
                  $headerValues = "~" . $headerValues;

                  for ($x = 1; $x < $count + 1; $x++) {
                           $singlz = explode('~', $headerValues);
                           $singlz = $singlz[$x];
                           $singlz = ":" . $singlz;

                           $singlz = explode(':', $singlz);
                           $singlz = $singlz[1];
                           $linesdkim = $linesdkim . $singlz . ":";
                  }

                  $linesdkim = substr($linesdkim, 0, -1);

                  $message = str_replace("\r", "", $message);
                  $message = str_replace("\n", "\r\n", $message);
                  $message = str_replace(" \r\n", "\r\n", $message);
                  $message = str_replace(" \n", "\r\n", $message);
                  $message = str_replace("  ", " ", $message);

                  $packstring = base64_encode(pack('H*', hash('sha256', $message)));
                  $linesdkim = strtolower($linesdkim);
                  $DKIMtime = time();
                  $dkimSignatureHeader = "v=1; a=rsa-sha256; c=relaxed/relaxed; d=$sendertld; s=default; t=$DKIMtime; q=dns/txt; l=" . strlen($message) . "; h=$linesdkim; bh=$packstring; b=";
                  $dkiim = "DKIM-Signature: " . $dkimSignatureHeader;
                  $tocanonicalise = $headerValues . $dkiim . "~";
                  $justvalue = $justvalue . $dkimSignatureHeader . "^";
                  $linesdkim = "";
                  $vac = "";
                  $couts = substr_count($tocanonicalise, '~');
                  for ($x = 1; $x < $couts; $x++) {
                           $singlz = explode('~', $tocanonicalise);
                           $singlz = $singlz[$x];
                           $singlz = ":" . $singlz;
                           $heade = explode(':', $singlz);
                           $heade = $heade[1];
                           $heade = strtolower($heade);
                           $vallld = explode('^', $justvalue);
                           $vallld = $vallld[$x];
                           $vallld = "^" . $vallld;
                           $heade = $heade . ":";
                           $vallld = substr($vallld, 1);
                           $vallld = $vallld . "~";
                           $vac = $vac . $heade . $vallld;
                  }

                  $tocanonicalise = str_replace("~", "\r\n", $tocanonicalise);
                  $vac = str_replace("~", "\r\n", $vac);
                  $tocanonicalise = substr($tocanonicalise, 2);

                  $justvalue = "";

                  $tocanonicalise = substr($tocanonicalise, 0, -2);
                  $vac = substr($vac, 0, -2);

                  $privKey = openssl_pkey_get_private($dkim_key_content);
                  if (!$privKey) {
                           die("ERROR: Invalid private key format or content in " . $dkim_file . ": " . openssl_error_string());
                  }

                  if (!openssl_sign($vac, $signature, $privKey, OPENSSL_ALGO_SHA256)) {
                           die("ERROR: DKIM signing failed: " . openssl_error_string());
                  }
                  
                  $signature = base64_encode($signature);
                  $vac = "";
                  $privKeyStr = "";

                  $tocanonicalise = $tocanonicalise . $signature;
                  $dkim = strstr($tocanonicalise, "DKIM-Signature: ");
                  $posss = strpos($tocanonicalise, 'DKIM-Signature:');
                  $tocanonicalise = substr($tocanonicalise, 0, $posss);

                  $poos = 0;
                  $poos2 = 0;
                  $current = 5;
                  $current2 = 8;
                  $dkim2 = "";
                  for ($ss = 0; $ss < strlen($dkim); $ss++) {
                           if ($dkim[$ss] == ' ') {
                                    $poos++;
                           }
                           if ($poos == $current) {
                                    $dkim2 = $dkim2 . "\r\n\t";
                                    $poos = 0;
                                    $current = 4;
                           }
                           if ($dkim[$ss] == ':') {
                                    $poos2++;
                           }
                           if ($poos2 == $current2) {
                                    $poos2 = 0;
                           }

                           if ($dkim[$ss] . $dkim[$ss + 1] . $dkim[$ss + 2] == 'bh=') {
                                    $dkim2 = $dkim2 . "\r\n\t";
                           }
                           if ($dkim[$ss] . $dkim[$ss + 1] == 'b=') {
                                    $dkim2 = $dkim2 . "\r\n\t";
                                    break;
                           }
                           $dkim2 = $dkim2 . $dkim[$ss];
                  }

                  $signature = "b=" . $signature;
                  $signature = chunk_split($signature, 73, "\r\n\t ");
                  $signature = substr($signature, 0, -4);
                  $dkim2 = $dkim2 . $signature;
                  $dkim2 = str_replace(" s=", "s=", $dkim2);
                  $dkim2 = str_replace(" h=", "h=", $dkim2);
                  $dkim2 = str_replace(" bh=", "bh=", $dkim2);
                  $dkim2 = str_replace("; \r\n", ";\r\n", $dkim2);
                  $tocanonicalise = $dkim2 . "\r\n" . $tocanonicalise . "\r\n" . $message . "\r\n.\r\n";
                  echo "[" . ($emailstartpoint + 1) . "] CREATE NEW DKIM SIGNATURE SUCCESSFULLY  .\n";
                  
                  if ($toresendlist) {
                           goto continationreform;
                  }


                  echo "[" . ($emailstartpoint + 1) . "] EMAIL DNS RESOLVER ERROR COUNT = " . $po . "\n";
                  echo "[" . ($emailstartpoint + 1) . "] EMAIL DESTINATION INVALID COUNT = " . $emalinvalid . "\n";


                  $useremaillles = $emailstartpoint;
                  // Connect to SMTP server on port 25 (or change to 587 if needed)
$port = '25'; 
$socket = stream_socket_client($serverre . ':' . $port, $errno, $errstr, 10, STREAM_CLIENT_CONNECT | STREAM_CLIENT_PERSISTENT);

if (!$socket) {
    echo "ERREUR : $errno - $errstr<br />\n";
    // Optionally handle reconnection here
    goto begicontinue;
}

$result = fread($socket, 1024);
echo "[" . ($emailstartpoint + 1) . "] SMTP RESPONSE = " . $result . "\n";

// If SMTP greeting does not start with 220, treat it as an error
if (strpos($result, "220") !== false) {
    if (strpos($result, "errors") !== false) {
        $emailstartpoint++;
        goto begicontinue;
    }
} else {
    if (strlen($result) > 0) {
        stream_socket_shutdown($socket, STREAM_SHUT_WR);
        fclose($socket);
        echo "[" . ($emailstartpoint + 1) . "] SMTP SERVICE NOT AVAILABLE = " . $result . "\n";
        // You can add additional logic here for blacklisted messages
        $emailstartpoint++;
        goto begicontinue;
    } else {
        echo "[" . ($emailstartpoint + 1) . "] BREAKING FOR EMPTY RESPONSE\n";
        stream_socket_shutdown($socket, STREAM_SHUT_WR);
        $emailstartpoint++;
        goto boo;
    }
}

// Prepare HELO/EHLO data (use your hostname)
$helodata = "HELO " . $helodata . "\r\n";

// Send HELO/EHLO command
if (is_resource($socket)) {
    $rett = fwrite($socket, $helodata);
    echo "[" . ($emailstartpoint + 1) . "] HELO SENT, bytes written: " . $rett . "\n";
    if ($rett === false) {
        echo "[" . ($emailstartpoint + 1) . "] ERROR writing HELO to socket.\n";
        stream_socket_shutdown($socket, STREAM_SHUT_WR);
        fclose($socket);
        goto begicontinue;
    }
} else {
    error_log("Socket resource is invalid before writing HELO");
    goto begicontinue;
}

$result = fread($socket, 1024);
echo "[" . ($emailstartpoint + 1) . "] SIGN RESPONSE = " . $result . "\n";

// Send STARTTLS command
fwrite($socket, "STARTTLS\r\n");
$result = fread($socket, 1024);
if ($argv[5]) {
    // Do nothing if $argv[5] is truthy
} else {
    if (substr_count($result, " ") > 1) {
        echo "[" . ($emailstartpoint + 1) . "] TLS RESPONSE = " . $result . "\n";
    } else {
        $result .= fread($socket, 1024);
        echo "[" . ($emailstartpoint + 1) . "] SSL RESPONSE = " . $result . "\n";
    }
}

// Check that the STARTTLS response contains an expected string
if (strpos($result, "Ready to start TLS") !== false ||
    strpos($result, "SMTP server ready") !== false ||
    strpos($result, "with TLS") !== false) {

    // Remove forced cipher option; let OpenSSL negotiate a good cipher.
    // Set SSL context options
    stream_context_set_option($socket, 'ssl', 'verify_peer', false);
    stream_context_set_option($socket, 'ssl', 'verify_peer_name', false);
    stream_context_set_option($socket, 'ssl', 'allow_self_signed', true);
    
    // Enable SNI and set the peer name to the server hostname
    stream_context_set_option($socket, 'ssl', 'SNI_enabled', true);
    stream_context_set_option($socket, 'ssl', 'peer_name', $serverre);
    
    // Set a broader crypto method for TLS negotiation
    $crypto_method = STREAM_CRYPTO_METHOD_TLS_CLIENT;
    if (defined('STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT')) {
        $crypto_method |= STREAM_CRYPTO_METHOD_TLSv1_3_CLIENT;
    }
    if (defined('STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT')) {
        $crypto_method |= STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT;
    }
    
    $crypto_enabled = stream_socket_enable_crypto($socket, true, $crypto_method);

    if ($crypto_enabled) {
        echo "[" . ($emailstartpoint + 1) . "] TLS encryption enabled successfully.\n";
        // Re-send HELO/EHLO after TLS negotiation if necessary
        $helo_write_result = fwrite($socket, $helodata);
        if ($helo_write_result === false) {
            echo "[" . ($emailstartpoint + 1) . "] ERROR writing HELO after TLS negotiation.\n";
            stream_socket_shutdown($socket, STREAM_SHUT_WR);
            fclose($socket);
            goto begicontinue;
        }
        $result = fread($socket, 1024);
    } else {
        echo "[" . ($emailstartpoint + 1) . "] ERROR enabling TLS encryption.\n";
        stream_socket_shutdown($socket, STREAM_SHUT_WR);
        fclose($socket);
        goto begicontinue;
    }
    echo "[" . ($emailstartpoint + 1) . "] POST-TLS RESPONSE = " . $result . "\n";
}

				  $mfrom = "MAIL FROM: <" . $senderemail . ">\r\n";

                  fwrite($socket, $mfrom);
                  $result = fread($socket, 1024);

                  echo "[" . ($emailstartpoint + 1) . "] PRT CONNECTED = " . $result . "";
                  
                  if (strpos($result, "SPF") !== false || strpos($result, "MX") !== false) {
                           sleep(2);
						   echo "[" . ($emailstartpoint + 1) . "] SPF NOT CONNECTED = " . $result . "\n";
                           stream_socket_shutdown($socket, STREAM_SHUT_WR);
                           fclose($socket);
                           goto begicontinue;
                  }

                  echo "[" . ($emailstartpoint + 1) . "] TOTAL REMAIN: " . ($vallent - $emailstartpoint + 1) . "\n";
                  

                  $bccs = $argv[3];
                  if ($vallent - $emailstartpoint + 1 < $argv[3]) {
                           $bccs = $vallent - $emailstartpoint + 1;
                  }

                  for ($io = 0; $io < $bccs; $io++) {
                           $useremail = $userparts[$emailstartpoint];
                           $emailstartpoint++;
                           $rcpto = "RCPT TO: <" . $useremail . ">\r\n";
                           fwrite($socket, $rcpto);
                           $result = fread($socket, 1024);
                           echo "[" . ($emailstartpoint) . "] CONFIG = ". $emailstartpoint . "   " . $io . "    " . $useremaillles . "    " . $vallent . "   " . $ttcount."\n";


                           if (strpos($result, "detected") > -1 || strpos($result, "SSL operation") > -1) {
                                  echo "[" . ($emailstartpoint + 1) . "] DETECTED = " . $result . "\n";
								  exit();
                           }

                           if ($argv[3] > 1) {
                                    if (strpos($result, "250") !== false) {
                                             if ($argv[8]) {
                                                      $ttl++;
                                                      ($myfile = fopen($argv[1] . "-reform", "a")) or die("Unable to open file!");
                                                      fwrite($myfile, $useremail . "\n");
                                                      fclose($myfile);
                                             }
                                    } else {
                                             $emalinvalid++;
                                             if ($emalinvalid == $maxipinv) {
                                                      echo "[" . ($emailstartpoint + 1) . "] ALMOST BROKEN IP LOUNCHE IP REINFORCE AFTER  = " . ($emalinvalid + 1) . " EMAIL INVALID\n";
                                                      sleep($delaynum);
                                                      $emalinvalid = 0;
                                             }
                                    }
                                    if ($ttl == $argv[3]) {
                                             echo "[" . ($emailstartpoint + 1) . "] BREAK BCC FOR NEXT  REFORM SEND\n";
                                             $ttl = 0;
                                             $toresendlist = 1;
                                             sleep(1);
                                             break;
                                    }
                           }

                           if ($io == $bccs - 1) {
                                    if ($argv[5]) {
                                    } else {
                                             echo "[" . ($emailstartpoint) . "] DONE BCC CHECK IF DESTINATION VALID FOR LAST BCC = $io  $bccs   $bccs\n";
                                    }
                           }
                  }

                  if ($argv[3] == 1) {
                           if (strpos($result, "250") !== false) {
                           } else {
                                    $emalinvalid++;
                                    if ($emalinvalid > $maxipinv) {
                                             echo "[" . ($emailstartpoint + 1) . "] BROKEN IP DESTINATION INVALID: " . $emalinvalid . "\n";
                                           
                                    }
                                    if (strpos($result, "459") !== false) {
                                             echo "[" . ($emailstartpoint + 1) . "] BROKEN IP SKYNET\n";
                                    }
                                    stream_socket_shutdown($socket, STREAM_SHUT_WR);
                                    fclose($socket);
                                    goto boo;
                           }
                  } else {
                           $emalinvalid = 0;
                  }

                  if ($argv[5]) {
                           fwrite($socket, "RSET\r\n");
                           $result = fread($socket, 1024);
						   echo "[" . ($emailstartpoint + 1) . "] RSET = " . $result . "\n";
                  } else {
                           if ($argv[3] > 1 && $argv[8]) {
                                    fwrite($socket, "RSET\r\n");
                                    $result = fread($socket, 1024);
									echo "[" . ($emailstartpoint + 1) . "] RSET = " . $result . "\n";
                              
                           }

                           if (isset($argv[8])) {
                           } else {
                                    fwrite($socket, "DATA\r\n");
                                    $result = fread($socket, 1024);
									echo "[" . ($emailstartpoint) . "] DATA = " . $result . "";
                                    

                                    fwrite($socket, $tocanonicalise);
                                    $result = fread($socket, 1024);
									echo "[" . ($emailstartpoint) . "] DATA = " . $result . "";
                               
                                    if (strpos($result, "SPF") !== false) {
										     echo "[" . ($emailstartpoint + 1) . "] SPF = " . $result . "\n";
                                             // socket_close($socket); // Use fclose for streams
                                             fclose($socket);
                                             exit();
                                    }
                                    if (strpos($result, "spam") !== false || strpos($result, "DMARC") !== false) {
										echo "[" . ($emailstartpoint + 1) . "] SPAM/DMARC = " . $result . "\n";
                                    } else {
                                             if ($argv[3] == 1) {
                                                      $ttcount++;
                                             }
                                    }
                           }
                  }

                  fwrite($socket, "QUIT\r\n");
                  $result = fread($socket, 1024);

                  echo "[" . ($emailstartpoint) . "] SUCCESSFULLY = " . $result . "";
                  
                  stream_socket_shutdown($socket, STREAM_SHUT_WR);
                  fclose($socket);

                  if ($argv[5]) {
                           ($myfile = fopen("start.txt", "w")) or die("Unable to open file!");
                           $txt = "1";
                           fwrite($myfile, $txt);
                           fclose($myfile);
                  }

                  if ($toresendlist) {
                           echo "\n+++++++++++++++++++ TRY TO SEND NOW REFORM LIST ++++++++++++++++++++++++\n";

                           goto upreformdata;

                           continationreform:

                           $toresendlist = 0;

                           $socket = stream_socket_client($serverre . ':' . '25', $errno, $errstr, '10', STREAM_CLIENT_CONNECT | STREAM_CLIENT_PERSISTENT);
                           if ($socket) {
                           } else {
                                    echo "\nCould not create socket retry REFORM LIST\n";
                                    sleep(2);
                                    goto continationreform;
                           }

                           $result = fread($socket, 1024);
                           echo "\nTHREAD REFORM LIST " . $myid . " : " . $serverre . ": " . $result;
                           if (strpos($result, "220") !== false) {
                                    if (strpos($result, "errors") !== false || strpos($result, "421") !== false) {
                                             exit();
                                    }
                           } else {
                                    if (strlen($result) > 0) {
                                             fclose($socket);
                                             echo "\nSMTP SERVICE NOT AVAILABLE = " . $usertld . "\n";
                                             if (
                                                      strpos($result, "Spamhaus") !== false ||
                                                      strpos($result, "Spamhaus.org") !== false ||
                                                      strpos($result, "551-5.7.1 Your IP is black listed by Spamhaus.org") !== false ||
                                                      strpos($result, "blacklisted") !== false ||
                                                      strpos($result, "postmaster") !== false
                                             ) {
                                                      exit();
                                             }
                                             sleep(2);
                                             fclose($socket);
                                    } else {
                                             echo "\nTHREAD " . $myid . " : BREACKING FOR EMPTY RESPONSE\n";
                                             sleep(1);
                                             fclose($socket);
                                             goto continationreform;
                                    }
                           }

                           $helodata = "HELO " . $helodata . "\r\n";
                           fwrite($socket, $helodata);
                           $result = fread($socket, 1024);
                           echo "\nTHREAD REFORM2 " . $myid . " : " . $serverre . ": " . $result;

                           fwrite($socket, "STARTTLS\r\n");
                           $result = fread($socket, 1024);

                           if (substr_count($result, " ") > 1) {
                                    echo "\nTHREAD FOR TLS1 " . $myid . " : " . $serverre . ": " . $result;
                           } else {
                                    $result .= fread($socket, 1024);
                                    echo "\nTHREAD FOR TLS2 " . $myid . " : " . $serverre . ": " . $result;
                           }

                           if (strpos($result, "Ready to start TLS") !== false || strpos($result, "SMTP server ready") !== false || strpos($result, "with TLS") !== false) {
                                    stream_context_set_option($socket, 'ssl', 'ciphers', 'AES256-SHA');
                           stream_context_set_option($socket, 'ssl', 'verify_peer', false);
                           stream_context_set_option($socket, 'ssl', 'verify_peer_name', false);
                           stream_context_set_option($socket, 'ssl', 'allow_self_signed', true);
                           $crypto_enabled_reform = stream_socket_enable_crypto($socket, true, STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT);

                           if ($crypto_enabled_reform) {
                               echo "THREAD " . $myid . " : SSL connect succeeded to socket " . $socket . "\n";
                               $helo_write_reform = fwrite($socket, $helodata);
                               if ($helo_write_reform === false) {
                                   echo "\nTHREAD REFORM " . $myid . " : ERROR writing HELO after TLS negotiation.\n";
                                   stream_socket_shutdown($socket, STREAM_SHUT_WR);
                                   fclose($socket);
                                   goto continationreform; // Retry reform
                               }
                               $result = fread($socket, 1024);
                           } else {
                               echo "\nTHREAD REFORM " . $myid . " : ERROR enabling TLS encryption.\n";
                               stream_socket_shutdown($socket, STREAM_SHUT_WR);
                               fclose($socket);
                               goto continationreform; // Retry reform
                           }
                                    echo "\nTHREAD " . $myid . " : " . $serverre . ": " . $result;
                           }

                           $mfrom = "MAIL FROM: <" . $senderemail . ">\r\n";
                           fwrite($socket, $mfrom);
                           $result = fread($socket, 1024);
                           echo "\nTHREAD $myid : $serverre: $result" . "" . $mfrom;

                           if (strpos($result, "SPF") !== false || strpos($result, "MX") !== false) {
                                    sleep(2);
                                    stream_socket_shutdown($socket, STREAM_SHUT_WR);
                                    fclose($socket);
                                    goto begicontinue;
                           }

                           for ($io = 0; $io < $argv[3]; $io++) {
                                    $usermails = $userpts[$io];
                                    $rcpto = "RCPT TO: <" . $usermails . ">\r\n";
                                    fwrite($socket, $rcpto);
                                    $result = fread($socket, 1024);

                                    echo "\nTHREAD $myid : $serverre: $result" . "" . $rcpto . " " . $io . " " . $ttcount . "\n";
                                    if (strpos($result, "too") > -1 || strpos($result, "detected") > -1 || strpos($result, "SSL operation") > -1) {
                                             sleep(50);
                                             fclose($socket);
                                    }
                           }

                           fwrite($socket, "DATA\r\n");
                           $result = fread($socket, 1024);
                           echo "\nTHREAD " . $myid . " : " . $serverre . ": " . $result;

                           fwrite($socket, $tocanonicalise);
                           $result = fread($socket, 1024);
                           echo "\nTHREAD " . $myid . " : " . $serverre . ": " . $result;
                           if (strpos($result, "SPF") !== false) {
                                    fclose($socket);
                           }
                           if (strpos($result, "spam") !== false || strpos($result, "DMARC") !== false) {
                                    stream_socket_shutdown($socket, STREAM_SHUT_WR);
                                    fclose($socket);
                                    sleep(2);
                                    goto upreformdata;
                           } else {
                                    $ttcount = $ttcount + $argv[3];
                           }
                           fwrite($socket, "QUIT\r\n");
                           $result = fread($socket, 1024);
                           echo "\nTHREAD " . $myid . " : " . $serverre . ": " . $result;

                           echo "\n++++++++++++ DONE WITH REFORM LIST ++++++++++++\n";

                           stream_socket_shutdown($socket, STREAM_SHUT_WR);
                           fclose($socket);
                           unlink($argv[1] . "-reform");
                  }

                  boo:

                  echo "[" . ($emailstartpoint) . "] HEADER SEND = " . strlen($tocanonicalise) . " /kb\n";
				  echo "[" . ($emailstartpoint) . "] EMAIL SENT SUCCESSFULLY .\n";
                  echo "--------------------------------------\n";
                  $dkim = "";
                  $tocanonicalise = "";
                  $message = "";
                  // $useremail is reassigned at the start of the loop

                  // Apply the user-defined delay from $argv[4] before the next email attempt
                  if ($emailstartpoint < $vallent) { // Only sleep if there are more emails to process
                           echo "Pausing for $delaynum seconds before next email ($emailstartpoint / $vallent processed)...\n";
                           sleep($delaynum);
                  }

         }
}

$emaillist = "";
if (strlen($filesname) > 0) {
         $bfille = "";
}
echo "--------------------------------------\n";
printf("[+] All tasks completed. \n");



?>
